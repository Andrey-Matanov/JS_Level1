<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1>Задание 2</h1>
    <p>1. Сначала компилятор просматривает все объявления функций сверху вниз, в итоге обявляются две функции 'a' (19 строка) и 'b' (14 строка).</p>
    <p>2. Далее компилятор начинает выполнять оставшийся код сверху вниз. В строке 1 условие принимает значение false (т.к. в документе обьявлена функция 'a', то она находится в объекте window, значит "var a = 1" не выполняется, но переменная a при этом все равно будет объявлена согласно особенностям принципа действия var. Но по сути a уже была объявлена как функция, так что 'a' была всего лишь повторна объявлена</p>
    <p>3. В строке 4 выводится 'a', а 'a' объявлена как функция на строке 19, поэтому выводится код этой функции </p>
    <p>4. В строке 5 объявляется переменная 'b' и ей присвается функция описанная в строках с 5 по 7, а значит 'b' теряет присвоенный ей вначале комплиятором код функции в строках 14-17. Исходя из пункта 1, что функция 'а' теперь описана по-другому, b присвается описание функции 'a' из строк с 19 по 21.</p>
    <p>5. В строке 8 выводится код функции a (строки 19-21).</p>
    <p>6. В строках 9-11 новое обьявление функции 'a', которое опять же, следуя из пункта 1, будет пропущено компилятором</p>
    <p>7. Строка 12: 'a' просто объявляется в очередной раз. Значением 'a' остается код функции на 19 строке.</p>
    <p>8. На 13 строке выводится код функции а при помощи alert</p>
    <p>9. В пункте 4 описано, что 'b' теперь равно функции 'a', так что описание этой функции больше не имеет значение. Однако я распишу что происходит в теле функции: 'x, y, a' - параметры функции, поэтому неважно как они называются, они будут использоваться лишь в самом теле функции, как локальные переменные, и не имеют никакого отношения к внешнему лексическому окружению функции. 'arguments' - объект, содержащий значения этих параметров функции, через arguments к ним можно обратиться напрямую. И в конце просто выводится значение параметра 'a' с помощью alert.</p>
    <p>10. Строка 18: вызов функции b с параметрами 1,2,3. К 'b' привязана функция, код которой описан в строках 5-7, поэтому при запуске кода на строке 18 запустится следующий код: x && a(--x), где x = 1. В данном контексте 'a' это функция 'a' объявленная в строке 5, '--x' - префиксный декремент, а значит выполнится следующее: 1 && a(0) => 1 && 0 && a(--x). Выполняя это выражение компилятор дойдет до 0 и дальше перестанет вычисления, и результатом этого выражения будет просто 0, и благодаря ленивым вычислениям рекурсии с бесконечным запуском a(--x) не будет.</p>
    <p>11. Строка 19-21. Обьявление функции 'a', которое она получит исходя из 1 пункта</p>
    <p>12. call - принимает в качестве параметров объект obj, а остальные параметры - это аргументы, с которыми call запускает функцию в контексте объекта obj. <br><br> Функция a вызывается в контексте null. Но при этом alert выводит глобальный объект. Почему в контексте null this становится глобальным объектом мне не совсем понятно.</p>

    <script src="index.js"></script>
</body>
</html>